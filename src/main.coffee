fs = require 'fs'
path = require 'path'
coffeescript = require 'coffee-script'
mkdirp = require 'mkdirp'
commander = require 'commander'

commander
	.version require('../package.json').version
	.usage '[options] <file ...>'
	#.command 'coffeemaker <file> [otherFiles...]'
	.option '-o, --output [path]', 'Set the output directory (or file when using --join) for compiled JavaScript.'
	.option '-w, --watch', 'Watch scripts for changes and rerun commands.'
	.option '-j, --join', 'Concatenate the source CoffeeScript before compiling.'
	.option '-b, --bare', 'Compile without a top-level function wrapper.'
	.option '-n, --now', 'Compile sources immediately (when using --join).'
	.parse process.argv

HEADER = "// Generated by Coffee-Maker #{require('../package.json').version}\n"
DEBUG = commander.debug ? false

do ->
	if not commander.args?.length then return console.error "[error] Nothing to compile."
	
	dir = path.resolve commander.args[0] ? process.cwd()
	out = path.resolve commander.output ? process.cwd()
	join = commander.join ? false
	watch = commander.watch ? false
	now = commander.now ? false
	
	options =
		persistent: true
		recursive: true
	
	if watch
		spotted = {}
		dirisdir = fs.lstatSync(dir).isDirectory()
		console.log '[info] Waiting for changes...'
		fs.watch dir, options, (event, filename) ->
			if spotted[filename]
				clearTimeout spotted[filename]
				
			spotted[filename] = setTimeout ->
				spotted[filename] = null
				if DEBUG then console.log "Change found in '#{filename}'."

				if join
					compile dir, dir, out, true
				
				else
					if dirisdir
						compile dir, path.join(dir, filename), out
					
					else
						compile dir, dir, out
			
			, 500
		
		if now then setImmediate -> compile dir, dir, out, join
	
	else
		setImmediate -> compile dir, dir, out, join

compile = (root, source, destination, join = false) ->
	coffees = {}
	iterate = (file, dirs = [], isRoot = true) ->
		name = path.basename file
		stat = fs.lstatSync file

		if stat.isDirectory()
			for sub in fs.readdirSync file
				iterate path.join(file, sub), (if isRoot then [] else dirs.concat([name])), false
		
		else if stat.isFile() and path.extname(file) is '.coffee'
			coffees[file] =
				data: fs.readFileSync file, 'utf8'
				relative: dirs.concat([name]).join '/'
		
		else if stat.isSymbolicLink()
			linkedFile = path.join path.dirname(file), fs.readlinkSync file
			stat = fs.lstatSync linkedFile
			
			if stat.isDirectory()
				for sub in fs.readdirSync linkedFile
					iterate path.join(linkedFile, sub), (if isRoot then [] else dirs.concat([name])), false
			
			else if stat.isFile() and path.extname(file) is '.coffee'
				coffees[linkedFile] =
					data: fs.readFileSync file, 'utf8'
					relative: dirs.concat([name]).join '/'
		
		null
	
	if root isnt source
		# happens only when watching a folder and not joining files
		rel = path.relative(root, source).split path.sep
		rel.pop()
		
		iterate source, rel
	
	else
		iterate source
	
	# Process includes
	
	resolving = {}
	resolved = {}
	resolve = (file, data) ->
		if resolved[file]
			return resolved[file]
		
		if resolving[file]
			console.error "[error] Recursive include '#{file}' found."
			reutrn ''
			
		if not data?
			if fs.lstatSync(file).isDirectory() then return ''
			data = fs.readFileSync file, 'utf8'
		
		resolving[file] = true
		resolved[file] = data.replace /^#include (.*)$/gm, (a, b) ->
			matches = b.split /\s*,\s*/
			included = []
			
			for match in matches
				inc = path.join(path.dirname(file), match)
				if fs.lstatSync(inc).isDirectory()
					console.warn "[warning] Invalid include '#{match}' in file '#{item.relative}'."
				else
					if fs.lstatSync(inc).isSymbolicLink()
						inc = path.join path.dirname(inc), fs.readlinkSync inc
					
					if join then delete coffees[inc]
					included.push resolve inc
			
			included.join '\n'

		resolving[file] = null
		resolved[file]
	
	for file, item of coffees
		#console.log file, ' -> ', item.relative
		
		item.data = resolve file, item.data
	
	coffeeopts =
		bare: commander.bare ? false
	
	if join
		joined = []
		for file in Object.keys(coffees).sort()
			for line, index in coffees[file].data.split '\n'
				joined.push
					file: file
					text: line
					line: index + 1
			
		mkdirp.sync path.dirname destination
		
		try
			fs.writeFileSync destination, HEADER + coffeescript.compile joined.map((line) -> line.text).join('\n'), coffeeopts
		catch ex
			if ex.location
				# coffee error
				console.error "[error] #{ex.name}: #{ex.message}\n        File: #{joined[ex.location.first_line]?.file}\n        Line: #{joined[ex.location.first_line]?.line}:#{ex.location.first_column}\n        Code: #{joined[ex.location.first_line]?.text.trim()}"
			
			else
				console.error "[error] #{ex.message}"
			
			return
			
		console.log "[compiled] #{destination}"
	
	else
		for file, item of coffees
			js = path.join(destination, item.relative.replace(/\.coffee$/, '.js'))
			mkdirp.sync path.dirname js
			
			try
				fs.writeFileSync js, HEADER + coffeescript.compile item.data, coffeeopts
			catch ex
				if ex.location
					# coffee error
					console.error "[error] #{ex.name}: #{ex.message}\n        File: #{file}\n        Line: #{ex.location.first_line + 1}:#{ex.location.first_column}\n        Code: #{item.data.split('\n')[ex.location.first_line]?.trim()}"
				
				else
					console.error "[error] #{ex.message}"
				
				continue
				
			console.log "[compiled] #{js}"
	
	#console.log 'Done.'